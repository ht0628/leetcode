数据结构体系

```
链表知识点：
	1.用虚拟头方便直接next。
	2.链表常用循环while(linkedList)
	3.多链表时的空节点判断
```

```
集合知识点：
	1.创：a = set() / a ={x1, x2, x3} / a = set(iter:str,list,tuple)
	2.增：a.add(iter) / a.update(iter)
	3.删：a.remove(x)--不存在会报错 / a.discard(x)--不存在不会报错 / a.pop()--随机删除一个 / a.clear()--清空
	4.改：无
	5.查：len(a) / x in a / 
	6.其他内置函数 https://www.runoob.com/python3/python3-set.html
```

### 数组体系

```python
常用算法: 1.双指针 2.动态规划 3.单调栈

I.数和题型
	数组内任意几个数的和 ———— 双指针 1 15 16 18
    连续子数组的和（包含所有滑窗长度） ———— 动态规划 53
    
II.统计图题型（数和题型的升级 经过一些复杂的过程之后再求和）
	总体步骤:顺应题目趋势找解算关键点，如11求水最多的容器，那么就去找让水增多的方向，方向可以用双指针表示。
    双指针，动态规划，单调栈。
    
III.原地删除体系
	都是双指针
    

```



| 操作     | 例题                                                         | AC   |
| -------- | ------------------------------------------------------------ | ---- |
| 数和     | [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)<br>[15. 三数之和](https://leetcode-cn.com/problems/3sum/)<br>[16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)<br>[18. 四数之和](https://leetcode-cn.com/problems/4sum/)<br>[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)<br>[66. 加一](https://leetcode-cn.com/problems/plus-one/) |      |
| 统计图   | [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)<br/>[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)<br/>[x-d84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) |      |
| 原地删除 | [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)<br>[27. 移除元素](https://leetcode-cn.com/problems/remove-element/)<br>[80. 删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/) |      |
| 重排     | [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)<br>[48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/) |      |
| 搜索     | [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)<br>[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)<br/>[34. 在排序数组中查找元素的第一个](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)<br>[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)<br>[81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)<br>[57. 插入区间](https://leetcode-cn.com/problems/insert-interval/) |      |
| 模拟     | [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)<br>[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/) |      |
| 路径     | [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)<br>[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) |      |
| 交互     | [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)<br/>[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/) |      |
|          |                                                              |      |
|          |                                                              |      |
| 其他     | [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)<br>[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)<br>[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)<br>[73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)<br>[74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)<br>[75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)<br>[85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)<br>[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)<br/> |      |

### 字符串体系

- 增

  使用 ‘+’ 可进行字符串的添加拼接；

- 改：

  注意：Python中的字符串是无法进行原地修改的，有以下几个修改字符串的方案：

  list(str) + ''.join(list)：转换成列表修改完之后再转换为字符串。

  使用内置函数：str.replace(old,new)进行原地修改。

- 查：

  使用内置函数：str.find(str, beg=0, end=len(string))

  手写kmp

- 删

```python
1.找字串
主旨：滑窗 or 动态规划
- 无重复最长字串
I.滑动set去重

- 最长回文子串
I.动态规划法(dp[i][j]表示s[i:j+1]字串是否为回文) or 中心扩散法(奇偶串)

- 最小覆盖字串
I.滑动dict+count计数

- 重复的DNA序列
I.固定的滑动dict + 单指针

2.变换
主旨：代码模拟
- Z字形变换
I.模拟Z形变换过程 + 方向变量flag

- 整数反转/回文数
I.通过求余反向遍历整数，
II.注意C++：-9/7=-1 -9%7=-2 Python：-9//7 = -2 -9%7=5 9%-7=-5。

- 字符串转换整数
I.去前空格 + 在字符串中提取除数字

- 整数转罗马数字
I.贪心算法(每次找最大能除的值)

- 罗马数字转整数
I.字典记录 + 两位一组遍历
II.字典记录 + 一位一组遍历 + 熟悉罗马数字特性

3.多字符串交互
- 最长公共前缀
I.利用python的zip()可以轻松提取字母，利用set()函数可以轻松的去重。
II.纯粹的遍历模拟，考察对循环的构造。

- 串联所有单词的子串
I.固定滑窗 + 字典统计

- 字符串相加/二进制求和
I.模拟竖式相加的流程 + 对进位的把控

- 字符串相乘
I.模拟优化的竖式相乘流程(先考虑单乘，再考虑进位)
II.充分利用python的enumerate特性。

- 字母异位词分组
I.字典统计 + 排序消除异位
```



| 字符串操作         | 例题                                                         |      |
| ------------------ | ------------------------------------------------------------ | ---- |
| 找子串             | [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)<br>[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)<br>[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)<br>[187. 重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/) | #1   |
| 变换               | [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)<br>[7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)<br/>[9. 回文数](https://leetcode-cn.com/problems/palindrome-number)<br>[8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)<br>[12. 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)<br>[13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)<br> | #2   |
| 多字符串交互       | [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)<br>[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)<br>[30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)<br>[415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)<br>[43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)<br>[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)<br>[67. 二进制求和](https://leetcode-cn.com/problems/add-binary/) | #3   |
| 括号               | [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)<br>[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)<br>[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/) |      |
| 正则               | [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)<br>[44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/) |      |
| 反转/翻转/花式反转 | 344.反转字符串【**首尾双指针**】<br> 541. 反转字符串II<br>151.翻转字符串里的单词<br>剑指 Offer 58 - II. 左旋转字符串 |      |
| 替换特殊字符       | 剑指Offer 05.替换空格#3                                      |      |
| 重复构成           | 459. 重复的子字符串【**kmp算法**】                           |      |

### 链表体系

```python
常用套路：
快慢指针、插头法、化数组/堆栈进行处理
1.设计操作
当做增加、删除列表节点操作时，其实最重要的就是找到对应位置的前一个节点。

2.删除操作
删除节点关键：找到节点前的点，然后cur.next = cur.next.next。
- 删除目标值：遍历cur.next + 删除节点
- 删除倒数节点：双指针找倒数节点 + 删除节点
- 删除无头节点：换值
- 删除中间节点：快慢指针找中点
  偶数链表时 
    while fast and fast.next找到是前面的；
    while fast.next and fast.next.next找到的是后面的；
- 删除重复元素：单指针去重，双指针删重
- 删合为0的子集：前缀和字典 核心思想：到两个结点的前缀和如果相等，则意味着两个结点之间的结点和为零。

3.反转操作
- 反转全部：双指针+python联立技巧
- 反转部分：三指针穿针引线(更新removed变量！！)或者三指针拼接。
  反转部分如果采用拼接法：
    I.找到反转部分的右端点，切断链表并记录下一个点：cur.next, curNext = None, cur.next
    II.记录旧头
    III.反转链表得到新头
    IV.根据新旧头进行链表连接
    V.更新pre,cur到旧头进行下一部分连接
- 复杂的部分反转：如果题目允许，可以将链表转化为列表进行操作。

注意python联立有个坑，右侧是一起评估的，但左侧是依次赋值的。
cur.next, pre, cur = pre, cur, cur.next
pre, cur, cur.next = cur, cur.next, pre
两者是不同的，第二个是错误的，因为cur被修改之后，cur.next可能不存在了。

4.多链表交互操作
同时遍历双链表技巧：while l1 and l2 或者 while l1 or l2
链表长度不同陷进：有一个链表可能提前遍历结束了，此时无法取值和.next
- 两链表顺序相加：进位考虑 + 链表长度不同陷阱 + 同时遍历双链表技巧 
- 两链表逆序相加：堆栈法 + 头插/反转构建链表 or 反转链表之后再相加再反转
- 两有序链表有序合并：链表长度不同陷阱 + 同时遍历双链表技巧
- K个有序链表有序合并：小顶堆heapq排序 + 链表构建
- 两链表相交判断：类似浪漫法，一直往前走，走不通就走对方的路。

5.花式重排链表
- 重排链表总技巧：画模拟图 -》确定基点 -》找到基点的Nxt点赋名 -》基点连接Nxt点 -》更新基点

- 旋转：计算链表长度 + 确定切断点 + 双指针法找到倒数的切断点 + 基本拼接
- 分隔：提取特定节点重构链表 + 基本拼接
- 穿插重排：找链表中点 + 反转链表 + 重排
- 奇偶重排：提取特定节点重排 + 基本拼接
- 交换相邻节点：模拟过程 + 重排
- 交换指定节点：交换值

6.找点/子集/和
均法链表：采用//求basic，采用%求+1组数。
切分成多段链表：用相邻双指针，慢指针用于切断尾部，快指针用于探索下一个点。
快慢双指针找中点：
        fast = slow = head
        while fast and fast.next: ---->其他未固定模板，此处可以控制偶数时中点的位置，此时为后一个。
        while fast.next and fast.next.next ---->此时为前一个
            fast = fast.next.next
            slow = slow.next
        return slow
link转list：当link处理比较复杂的问题时，还是转成list较为方便。
找极值点：遍历夹逼法
- 分隔链表：均分链表 + 切分成多端链表
- 链表组件：集合判断存在情况 + 组件统计
- 寻找中间节点：快慢双指针找中点
- 下一个更大节点：凡是找右侧下一个更xx的点都是用起单调栈。
- 找局部极值点：link转list + 找极值点 + 求距离
- 孪生和：链表中点 + 链表反转 + 双链表相加

7.复制操作
- 复制复杂链表：字典映射链表获取全局节点 + 复制原链表的链接方式

8.环形链表
快慢指针：快指针每次两步，慢指针每次一步。
环形浪漫法：有环形总会相遇
- 环形链表判断：快慢指针 + 环形浪漫法
- 寻找环形入口：环形链表判断 + 首尾指针相遇处即入口

9.排序
- 插入排序：一旦涉及到插入操作，那一定是要找到插入点的前后结点赋名，这样看起来清晰。插入排序注意是要有一个已经排序好的前缀，插入点则要从头开始遍历。
- 归并排序：链表查找中点切分 + 递归切分 + 有序合并
	陷阱：划分列表时，要使用while fast.next or fast.next.next 否则列表长度为2时会出现死循环。
```



| 链表操作                  | 例题                                                         | 方法 |
| ------------------------- | ------------------------------------------------------------ | ---- |
| 设计                      | [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)<br>[x355. 设计推特](https://leetcode-cn.com/problems/design-twitter)<br>[x622. 设计循环队列](https://leetcode-cn.com/problems/design-circular-queue)<br>[x641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque)<br>[x705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset)<br>[x706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap)<br>[x1206. 设计跳表](https://leetcode-cn.com/problems/design-skiplist)<br>[x1472. 设计浏览器历史记录](https://leetcode-cn.com/problems/design-browser-history)<br>[x1670. 设计前中后队列](https://leetcode-cn.com/problems/design-front-middle-back-queue) | #1   |
| 删除目标值/节点/重复/子集 | [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)<br>[19. *删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)<br>[237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)<br/>[2095. 删除链表的中间节点](https://leetcode-cn.com/problems/delete-the-middle-node-of-a-linked-list/)<br>[82. *删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)<br/>[83. *删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)<br>[1171. 从链表中删去总和值为零的连续节点](https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/) | #2   |
| 反转全部/部分             | [206. *反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)<br>[92. *反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)<br>[25. *K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)<br>[2074. 反转偶数长度组的节点](https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups/) | #3   |
| 多链表交互                | [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers)<br>[445. *两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)<br>[21. *合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)<br>[23. *合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists)<br>[1669. 合并两个链表](https://leetcode-cn.com/problems/merge-in-between-linked-lists/)<br>[160. *相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)<br> | #4   |
| 花式重排                  | [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)<br>[86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)<br>[143. *重排链表](https://leetcode-cn.com/problems/reorder-list/)<br>[328. *奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list)<br>[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)<br>[1721. 交换链表中的节点](https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list)<br> | #5   |
| 找点/子集/和              | [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts)<br>[817. 链表组件](https://leetcode-cn.com/problems/linked-list-components/)<br>[876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list)<br>[1019. 链表中的下一个更大节点](https://leetcode-cn.com/problems/next-greater-node-in-linked-list/)<br>[2058. 找出临界点之间的最小和最大距](https://leetcode-cn.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points)<br>[2130. 链表最大孪生和](https://leetcode-cn.com/problems/maximum-twin-sum-of-a-linked-list) | #6   |
| 复制                      | [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer) | #7   |
| 环形                      | [141. *环形链表](https://leetcode-cn.com/problems/linked-list-cycle)<br>[142. *环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii) | #8   |
| 排序                      | [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list)<br>[148. *排序链表](https://leetcode-cn.com/problems/sort-list) | #9   |
| 缓存                      | [x146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache)<br>[x460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache) | #10  |
| 二叉树                    | [x109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree)<br>[x114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list)<br>[x1367. 二叉树中的列表](https://leetcode-cn.com/problems/linked-list-in-binary-tree) |      |

### 二叉树体系

```
一、遍历
I)144、94、145 ==》前中后序遍历有三种方法：递归法、迭代法、模板法 ==》前序是自顶向下遍历，其他反之。
  - 对于递归法，写法基本是一致的，缺点是需要多写一个函数。
  - 对于迭代法，写法不一致。
    - 前序用栈(stack)模拟递归，注意入栈顺序是先右后左。
    - 后序与前序相似，入栈顺序相反，最后多一步reverse的操作。
    - 中序用栈(stack)和指针(cur)模拟递归，指针一边左下行一边入栈 ==》指空时，出栈修改指针 ==》指针右下		 行
  - 对于模板法，写法一致。增加nullptr的标志将入栈操作和取值操作分离，语法采用if-else，条件为标志判断。注	 意：1.入栈顺序和遍历顺序相反；2.读到nullptr时，要pop两次。

II)102 ==》层序遍历仅有一种迭代法。
  - 采用数据结构双向队列deque<TreeNode*>
  - 注意每一层循环遍历时，要提前int n = q.size()，而不能直接用q.size()，因为q的size一直发生变化。	
  
III)103 ==》之字形遍历 ==》在层序遍历的基础上增加顺序leftOrder标志位，控制双向队列deque的取值方向。

IV)105、106、889 ==》根据三序遍历重构问题关键就是找到左右子树划分点，再进行递归。
  - 前+中：在中序中查找前序的第一个节点
  - 前+后：在后序中查找前序的第二个节点
  - 中+后：在中序中查找后序的最后一个节点
  
二、二叉搜索树
两大题型：中序遍历二叉搜索树 || 有序数据结构构造二叉搜索树 
I)98、99、173、230 ==》这两题解题关键就在于知道二叉搜索树的中序遍历是有序的！==》采用中序遍历迭代/递归遍历。
  - 98：可以中序遍历之后再判断，也可以一边遍历一边判断。
  - 99：与写法类似，只是目的变成了找不有序的两个点。
  - 173：将中序迭代遍历写在next()函数中
  - 230：中序遍历到第K个结束

II)96、95 ==》有序数组任取一个点，左右两侧的数据刚好可以递归构造出二叉搜索树的左右子树集合，在左右两子树集              合中任意取一个就可以组合成一个二叉搜索树了。

III)105、106 ==》类似95和96，只是这两题加了一个平衡的条件，因此不能任取一点，只能取重点。

三、 二叉树的特征&&交互
两大题型：自顶向下(先序) || 自底向上(后序)【主要用于深度问题】
I) 100、617 ==》都是两棵树进行交互的问题，先对两者的根节点进行业务操作，再对左右节点递归操作。

II)226、101 ==》都是验证自身树特性问题，先对根节点/根左右进行业务操作，再对根左右节点/外内节点递归操作。

III)104、111、110 ==》涉及到深度问题一般都是自底向上的方针。其他都是细节问题。
	-104：max(left,right) + 1
	-111：return (left && right) ? min(left,right) + 1 : 1 + left + right;
	-110：自底向上求高度，如果不平衡则返回-1.
	
IV)199、513、404 ==》遍历问题 ==》根据目的灵活选择遍历顺序.
	-199：求右视图，带深度的自顶向下，根右左。
	-513：求左下角，带深度的自顶向下，根左右。
	-404：求左叶子之和，普通先序即可。
V)222 ==》完全二叉树特性 + 递归思想

四、路径问题
I)112、113、437、124 ==》dfs(自顶向下) + 回溯问题
	-112：不保存路径，仅仅返回bool ==》先序 + 判断业务 + return bool回溯
	-113：保存路径并返回 ==》先序 + 判断添加 + pop回溯路径
	-437：不保存路径，仅仅返回次数 ==》先序 + 前缀和业务 + 字典回溯
	-124：不保存路径，仅仅返回和值 ==》先序 + 累加业务 + 无回溯
II)129 ==》非根节点路径 ==》自底向上

五、填充指针问题
I)116、117 ==》遍历问题
	-116：因为是完美二叉树，所以每个节点的操作可以一致，因此可以采用dfs先序。
	-117：因为是普通二叉树，所以每个节点操作无法一致，最佳就是采用改动的层序遍历 + 链表思想。

```

| 二叉树操作       | 例题（LeetCode500）                                          |
| ---------------- | ------------------------------------------------------------ |
| 遍历             | [*144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)<br>[*94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)<br>[*145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)<br>[*102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)<br>[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)<br>[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)<br>[*105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)<br>[*106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)<br>[*889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) |
| 二叉搜索树       | [*98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)<br/>[99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)<br/>[173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)<br>[230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)<br/>[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)<br/>[95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)<br>[108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)<br>[109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)<br>[*剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)<br>[114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/) |
| 二叉树特征&&交互 | [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)<br/>[*617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)<br/>[*226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)<br/>[*101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)<br/>[*104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)<br>[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)<br/>[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)<br/>[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)<br>[513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)<br>[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)<br>[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/) |
| 路径             | [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)<br>[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)<br>[437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)<br>[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)<br>[129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/) |
| 填充指针         | [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)<br>[117. 填充每个节点的下一个右侧节点](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/) |
| 祖先             | [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)<br>[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) |

### 回溯算法体系

```python
回溯算法总体大模板：
def fun(self, ...)
#----------------------------------#
##处理传参
I.考虑空输入等可以直接返回的情况
    if xxxx:
        return xx
    
II.对传参进行排序[如组合问题中，nums具有重复的数据情况]
	nums.sort()
    
III.输入有映射关系的[如17.电话号码的组合]
    d = {2:"abc",3:"def",4:"ghi",5:"jkl",6:"mno",7:"pqrs",8:"tuv",9:"wxyz"}
    t = []
    for c in digits:
        t.append(d[int(c)])
#----------------------------------#
##定义输出和路径存储变量
I.常规情况
	res,path = [],[]
    
II.棋盘类型
	res = []
    #mxn的棋盘
    path = [['.'] * n for i in range(m)]
    
III.输出为False/True的
	#res不定义，依靠traceback的return。
    #path同上
#----------------------------------#
##定义辅助判断变量
I.排序/二维矩阵搜索问题中常用的防止异层复取的used数组
	used = [0] * len(nums)
    
II.N皇后问题中防止同一行、列、斜线的三大集合
        c = set()
        dia1 = set()
        dia2 = set()
#----------------------------------#
##定义traceback函数
I.组合问题和子集是无序的，所以不可以复取，当在一个给定的列表nums中取数字时，传参通常包含startIdx。
II.切割问题也需要startIdx，此时的startIdx表示切割的起始位置。
例如 77.组合、39.组合总和、40.组合总和II、216.组合总和III、78.子集、90.子集II、131.分割回文串、93.复原IP地址
def traceback(..., startIdx)

III.部分组合问题表示取下一个数的idx、N皇后问题表示取下一行的row
例如 17.电话号码的字母组合、51.N皇后、52.N皇后II
def traceback(..., idx/row)

IV.二维矩阵搜索问题 
例如 79.单词搜索 130.被围绕的区域 212.单词搜索2
def traceback(..., row, col)

V.辅助判断情况：当定义了辅助判断变量如used,或者迭代中辅助剪支/终止变量如 22.括号生成
def traceback(..., used, left, right, sum)
#----------------------------------#
##收集结果并做返回
I.子集问题收集所有的节点
	res.append(path[:])

II.其他问题大多收集叶子节点
	if 不满足剪支条件 and 满足返回条件: #通常由len(path) 或者 辅助剪支/终止变量判断
        res.append(path[:])
#----------------------------------#
##for循环路径选择
I.给定叶子节点高度k - 77.组合 216.组合总和III
	for i in range(startIdx, n - (k-len(path)) + 2)

II.求所有的叶子节点 - 39.组合总和 40.组合总和2 90.子集 xx.排列问题 xx.N皇后问题
	for i in range(startIdx, n)
    for i in range(n)
    
III.有固定搜索方向的 - 层间选取独立 or 矩阵搜索 - 17.电话号码的字母组合 + 22.括号生成 + xx.矩阵搜索
	for dir in dirs:...
#----------------------------------#
##路径添加前的预处理：如预判剪支、去除重复路径、防止重用元素、筛选等等
I.预判剪支，避免迭代 - 39.组合总和 93.IP分割
    if sum + candidates[i] > target: 【排序了后面都不考虑就return】
        return
    if len(s) - i - 1 > 3 * (3 - len(path)) or len(s) - i - 1 < (3 - len(path)):
        continue					 【后面还考虑就continue】

II.给定的组合中有重复元素，避免重复路径 - 40.组合总和2 90.子集II
	if i > idx and candidates[i] == candidates[i-1]:
    	continue

III.防止重用元素，一般有used数组，或N皇后斜线set等等
	if used[i]:
        continue

IV.筛选条件 - 因题而异
#----------------------------------#
##添加元素
I.path类型
	path.append(xx)

II.棋盘类型
	board[i][j] = xx
#----------------------------------#
##开始迭代
I.每次都从头开始选取元素
traceback(...,i)

II.每次都从选择的后一位选取元素
traceback(...,i+1)

III.每次都修改辅助终止变量
traceback(xx+i)
traceback(n, left+1, right)

IV.无res内嵌返回
if traceback(xxx):return True
#----------------------------------#
##回溯元素
path.pop()
辅助变量回溯
#----------------------------------#
##调用回溯
I.非搜索问题
traceback(xxxx)
II.搜索问题
for i in xxx
	tracback(i,...)	#设置搜索起点
```



| 类型     | 例题                                                         |
| -------- | ------------------------------------------------------------ |
| 组合     | [77. 组合](https://leetcode-cn.com/problems/combinations/)<br/>[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)<br>[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)<br>[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)<br>[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)<br>[216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/) |
| 排列     | [46. 全排列](https://leetcode-cn.com/problems/permutations/)<br/>[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/) |
| 子集     | [78. 子集](https://leetcode-cn.com/problems/subsets/)<br/>[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/) |
| 分割     | [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)<br/>[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/) |
| 棋盘问题 | [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)<br>[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)<br>[52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/) |
| 矩阵搜索 | [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)<br/>[212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)<br>[130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)<br>[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/) |
| 二叉树   | [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)<br>[95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) |
| 特殊     | [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)<br/>[126. 单词接龙 II](https://leetcode-cn.com/problems/word-ladder-ii/)<br>[140. 单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/) |

### 







### 滑动窗口体系

| 窗口内操作 | 数据结构                          | 例题                                                         |
| ---------- | --------------------------------- | ------------------------------------------------------------ |
| 无重复     | set                               | 3.无重复最长字串<br>剑指 Offer 48. 最长不含重复字符的子字符串 |
| 覆盖/包含  | dict+cnt                          | 76_最小覆盖子串<br>面试题 17.18. 最短超串                    |
| 和         | 变量sum                           | 209_长度最小的子数组<br>剑指 Offer II 008. 和大于等于 target 的最小子数组 |
| 积         | 变量mul                           | 滑窗内相乘除要考虑左指针不大于右指针<br>剑指 Offer II 009. 乘积小于 K 的子数组 |
| 最大/小值  | 单调递减/增队列                   | 剑指 Offer 59 - I. 滑动窗口的最大值<br>239_滑动窗口的最大值  |
| 变位词包含 | 一固一滑长度相等的双字典          | 剑指 Offer II 014. 字符串中的变位词<br>438. 找到字符串中所有字母异位词 |
| 替换字母   | 26字母数组 or counter.most_common | 424. 替换后的最长重复字符                                    |
| 中位数     | 难！                              |                                                              |

| 滑窗类型     | 例题                                                         |
| ------------ | ------------------------------------------------------------ |
| 变长滑窗     | 3.无重复最长字串<br/>76. 最小覆盖子串<br/>209. 长度最小的子数组 |
| 固定滑窗     | 30. 串联所有单词的子串<br/>187. 重复的DNA序列<br/>           |
| 上限固定滑窗 | 219. 存在重复元素 II                                         |

```python
线索：
	1.子串/连续子数组/连续子序列
	
知识点：
	1.窗口长度变化的双指针窗口
	2.窗口长度固定的单指针窗口

套路：
- 窗口长度变化
右指先行 -- 符合条件控制左指循环更新窗口 -- 更新窗口过程中在恰当时机进行结果更新
- 窗口长度固定
按固定长度切割出所有的子窗口 -- 对子窗口进行分析
- 窗口类型
根据题意选择适当的数据结构，如集合，字典，单调递减队列，无等。
窗口内无重复 -- 集合。
窗口内取最大值 -- 单调递减队列
- trick

变长窗口模板
#step1 定义维护的变量
left = 0 	#左指针
res = 0 	#定义实时更新的结果变量
record = xx #定义record的数据结构
other = xx 	#辅助判断的一些维护变量
#备注 窗左和窗右的更新顺序可以替换，如3就是先左，76就是先右。其次结果的更新可以独立出来也可以在更窗中，但一定要放在最后，否则最后一个指针更新不到了。如果更新结果嵌入左窗更新中，则return的时候要注意用if else
#step2 右指针开始移动
for right in range(len(xx)):
    #step3 更新窗口左侧
    while(右指针停止的条件)：
    	update record by left #窗口移除式更新
    	left += 1	            #移动左指针
    #step4 更新窗口右侧
    update record by right         #窗口添加式更新
    #step5 更新结果
    update res					#更新结果变量，往往和right left 有关。

```



### 动态规划体系

| 操作       | 例题                                                         |      |
| ---------- | ------------------------------------------------------------ | ---- |
| 连续子数组 | [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)<br/> |      |
|            |                                                              |      |
|            |                                                              |      |





