## 算法体系

### 回溯算法体系

```python
回溯算法总体大模板：
def fun(self, ...)
#----------------------------------#
##处理传参
I.考虑空输入等可以直接返回的情况
    if xxxx:
        return xx
    
II.对传参进行排序[如组合问题中，nums具有重复的数据情况]
	nums.sort()
    
III.输入有映射关系的[如17.电话号码的组合]
    d = {2:"abc",3:"def",4:"ghi",5:"jkl",6:"mno",7:"pqrs",8:"tuv",9:"wxyz"}
    t = []
    for c in digits:
        t.append(d[int(c)])
#----------------------------------#
##定义输出和路径存储变量
I.常规情况
	res,path = [],[]
    
II.棋盘类型
	res = []
    #mxn的棋盘
    path = [['.'] * n for i in range(m)]
    
III.输出为False/True的
	#res不定义，依靠traceback的return。
    #path同上
#----------------------------------#
##定义辅助判断变量
I.排序/二维矩阵搜索问题中常用的防止异层复取的used数组
	used = [0] * len(nums)
    
II.N皇后问题中防止同一行、列、斜线的三大集合
        c = set()
        dia1 = set()
        dia2 = set()
#----------------------------------#
##定义traceback函数
I.组合问题和子集是无序的，所以不可以复取，当在一个给定的列表nums中取数字时，传参通常包含startIdx。
II.切割问题也需要startIdx，此时的startIdx表示切割的起始位置。
例如 77.组合、39.组合总和、40.组合总和II、216.组合总和III、78.子集、90.子集II、131.分割回文串、93.复原IP地址
def traceback(..., startIdx)

III.部分组合问题表示取下一个数的idx、N皇后问题表示取下一行的row
例如 17.电话号码的字母组合、51.N皇后、52.N皇后II
def traceback(..., idx/row)

IV.二维矩阵搜索问题 
例如 79.单词搜索 130.被围绕的区域 212.单词搜索2
def traceback(..., row, col)

V.辅助判断情况：当定义了辅助判断变量如used,或者迭代中辅助剪支/终止变量如 22.括号生成
def traceback(..., used, left, right, sum)
#----------------------------------#
##收集结果并做返回
I.子集问题收集所有的节点
	res.append(path[:])

II.其他问题大多收集叶子节点
	if 不满足剪支条件 and 满足返回条件: #通常由len(path) 或者 辅助剪支/终止变量判断
        res.append(path[:])
#----------------------------------#
##for循环路径选择
I.给定叶子节点高度k - 77.组合 216.组合总和III
	for i in range(startIdx, n - (k-len(path)) + 2)

II.求所有的叶子节点 - 39.组合总和 40.组合总和2 90.子集 xx.排列问题 xx.N皇后问题
	for i in range(startIdx, n)
    for i in range(n)
    
III.有固定搜索方向的 - 层间选取独立 or 矩阵搜索 - 17.电话号码的字母组合 + 22.括号生成 + xx.矩阵搜索
	for dir in dirs:...
#----------------------------------#
##路径添加前的预处理：如预判剪支、去除重复路径、防止重用元素、筛选等等
I.预判剪支，避免迭代 - 39.组合总和 93.IP分割
    if sum + candidates[i] > target: 【排序了后面都不考虑就return】
        return
    if len(s) - i - 1 > 3 * (3 - len(path)) or len(s) - i - 1 < (3 - len(path)):
        continue					 【后面还考虑就continue】

II.给定的组合中有重复元素，避免重复路径 - 40.组合总和2 90.子集II
	if i > idx and candidates[i] == candidates[i-1]:
    	continue

III.防止重用元素，一般有used数组，或N皇后斜线set等等
	if used[i]:
        continue

IV.筛选条件 - 因题而异
#----------------------------------#
##添加元素
I.path类型
	path.append(xx)

II.棋盘类型
	board[i][j] = xx
#----------------------------------#
##开始迭代
I.每次都从头开始选取元素
traceback(...,i)

II.每次都从选择的后一位选取元素
traceback(...,i+1)

III.每次都修改辅助终止变量
traceback(xx+i)
traceback(n, left+1, right)

IV.无res内嵌返回
if traceback(xxx):return True
#----------------------------------#
##回溯元素
path.pop()
辅助变量回溯
#----------------------------------#
##调用回溯
I.非搜索问题
traceback(xxxx)
II.搜索问题
for i in xxx
	tracback(i,...)	#设置搜索起点
```

#### 题型总结

- 整体分析

```C++
回溯 && DFS的区别：
    回溯会走回头路，DFS一路爆搜，当然，一些隐藏回溯看起来非常像DFS。

一维特性：
I)递归函数的传参构造：
    void traceback(题目给的, res, path, idx, 辅助变量);
	path ==> res是双层vector& ==> path是单层vector&
         ==> res是单词vector& ==> path可以不使用&,将回溯隐藏在递归中
    
    idx ==> 不能走回头路 ==> 存在idx传参 
        ==> 能走回头路 ==> 不存在idx传参
        
    辅助变量 ==> 辅助终止条件的判断如(括号的左右数量left/right，排列问题的使用情况visited)

II)递归终止条件：
   1. 对最原始输入的全局判断；
   2. 搜索过程中的剪支判断；
   3. 达成条件，记录路径的判断；

III)递归部分：
   1. 构造for循环/枚举做选择 ==> 总共取的个数是固定的 ==> for循环剪支：for(int i=idx; i<=n-(k - path.size())+1; i++)
        				  ==> 总共取得个数不是固定的 ==> for(int i=idx; i<=n; i++)
   2. 辅助剪支 ==> 组合去重 ==> if(i > idx && candidates[i] == candidates[i - 1]) continue;
			  ==> 排列去重 ==> if(i > 0 && nums[i] == nums[i-1] && visited[i-1] == 0) continue;
			  ==> 排列防复取 ==> if(visited[i] == 1) continue;
   3. 存储 + 递归 + 回溯：
      存储 ==> path存储 ==> 辅助变量存储
      递归：存在idx ==> 可以复取 ==> idx = i
       		      ==> 不可用复取 ==> idx = i + 1
       	   path，辅助变量参数是非引用的 ==> 改变在传参中
      回溯 ==> path回溯 ==> 辅助变量回溯
VI)主函数部分：
   1. 去重情况 ==> sort(nums.begin(), nums.end());
			 

二维特性(相比一维的改动)：
    写法大纲：for循环写法 ==> 前馈控制；枚举写法 ==> 反馈控制；
    新增概念遍历自由度：
    	下一时刻的方向是确定的(解数独) ==> 遍历自由度0
    	下一时刻的方向是下一行(N皇后) ==> 遍历自由度1
    	下一时刻的方向是上下左右(单词搜索) ==> 遍历自由度2
    构造函数发生转变：
        返回类型：如果找到一个答案就返回，那么将void修改为bool;
    	path ==> 二维的board; 
		idx ==> 根据遍历自由度0,1,2 ==> 无 || row || row,col; 
		辅助变量 ==> 辅助剪支判断如N皇后的三集合、防止重复搜索的visited。
    主函数发生转变：
        搜索的题型(单词搜索) ==> 遍历设置搜索初始点; 

```



#### 题型分类

| 类型 | 例题                                                         | 特性                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 组合 | [77. 组合](https://leetcode-cn.com/problems/combinations/)<br/>[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)<br>[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)<br>[216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)<br>[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)<br/>[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/) | 77.组合：不同的k个数的组合。<br/>39.组合总和：无重复元素&&可复取&&个数不固定的组合总和。<br/>40.组合总和II：有重复元素&&不可复取&&个数不固定的组合总和。<br/>216.组合总和III：无重复元素&&不可复取&&个数固定的组合总和。<br/>17.电话号码的字母组合：不同的k组字母的组合。<br/>22.括号生成：n组括号的组合。 |
| 排列 | [46. 全排列](https://leetcode-cn.com/problems/permutations/)<br/>[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/) | 46.全排列：无重复元素集合的全排列。<br/>47.全排列II：有重复元素集合的全排列。 |
| 子集 | [78. 子集](https://leetcode-cn.com/problems/subsets/)<br/>[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/) | 78.子集：无重复元素集合的子集<br/>79.子集II：有重复元素集合的子集 |
| 分割 | [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)<br/>[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)<br>[140. 单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/) | 93.复原IP地址：分割次数固定<br/>131.分割回文串：分割次数不固定<br/>140.单词拆分II：分割次数不固定 |
| 二维 | [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)<br>[52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)<br>[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)<br>[37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)<br/>[79. 单词搜索](https://leetcode-cn.com/problems/word-search/)<br/>[212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/) | 51.N皇后：下一时刻方向是下一行 &&返回棋谱<br/>52.N皇后II：下一时刻方向是下一行 &&返回方案数<br/>36.有效的数独：单纯证明数独有效性<br/>37.解数独：下一时刻方向确定&&返回第一个成功的棋谱<br/>79.单词搜索：搜索单一单词<br/>212.单词搜索：搜索多个单词 |



### D/BFS体系

#### 题型总结

```
此处排除二叉树的问题：二叉树的题目同一在二叉树体系
dfs ==> 部分二维搜索问题
bfs ==> 部分二维搜索问题 + 最短路径问题 + 无向图问题
```

#### 题型分类

| 类型 | 例题                                                         |
| ---- | ------------------------------------------------------------ |
| DFS  | [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)<br/>[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)<br/>[463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)<br/>[695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)<br/>[827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island/) |
| BFS  | [126. 单词接龙 II](https://leetcode-cn.com/problems/word-ladder-ii/)<br>[127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)<br>[130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)<br>[133. 克隆图](https://leetcode-cn.com/problems/clone-graph/) |



### 动态规划体系

#### 题型总结

- 一维dp的构造
  - dp[i]表示前i个字符的dp值。
  - dp[i]表示以第i个字符结尾的dp值。
  - dp[i]表示题目求什么就是什么。

- 二维dp的构造
  - 回文系列——dp_ij表示以i起始，以j结尾的dp值。
  - 交互系列——dp_ij表示s1[:i]和s2[:j] 或者 s1[i:]和s2[j:]的dp值。

```c++
II.子串问题
1. 回文串问题 ==> 二维dp ==> 边界判断 + 相邻关系
    /* 5.最长回文子串 */
    string longestPalindrome(string s);
	/* 131.分割回文串 */
	vector<vector<string>> partition(string s); = 5 + 回溯
	/* 132.分割回文串II */
	int minCut(string s); = 5 + 分割次数dp

2. 两字符串匹配问题 ==> 二维dp ==> 边界判断 + 相邻关系
    /* 44. 通配符匹配 */
    bool isMatch(string s, string p);
	/* 10.正则表达式匹配 */
	bool isMatch2(string s, string p);        

3. 字符串拆分成子串问题
    /* 139.单词拆分 */
    bool wordBreak(string s, vector<string>& wordDict);
    /* 140.单词拆分II */
    vector<string> wordBreak2(string s, vector<string>& wordDict); = 139 + 回溯
    /* 343.整数拆分 */
    int integerBreak(int n);
	
III.子序列问题
1. 两字符串交互序列 && 单字符的回文序列问题 ==> 二维dp ==> 边界判断 + 相邻关系
	/* 115.不同的子序列 */
    int numDistinct(string s, string t);                                                                         /* 392.判断子序列 */
    bool isSubsequence(string s, string t);    
    /* 1143.最长公共子序列 */                                                                                     int longestCommonSubsequence(string text1, string text2);
    /* 516.最长回文子序列 */                                                                                       int longestPalindromeSubseq(string s);
                                                                                                             2.LIS && LCIS问题 ==> 一维dp ==> dp[i] = max(dp[j]) + 1(0 <= j < i)
    /* 300.最长递增子序列 */                                                                                       int lengthOfLIS(vector<int>& nums);                                     
    /* 334.递增的三元子序列 */                                                                                     bool increasingTriplet(vector<int>& nums);                    
    /* 673.最长递增子序列的个数 */                                                                                 int findNumberOfLIS(vector<int>& nums); == 300 + count[i]                      
    /* 674.最长连续递增序列 */                                                                                     int findLengthOfLCIS(vector<int>& nums);  
                                                                                                             
3.其他特殊子序列问题
    /* 446.等差数列划分 II - 子序列 */                                                                             int numberOfArithmeticSlices(vector<int>& nums);    
	/* 198.打家劫舍 */ ==> rob the last or not
	int rob(vector<int>& nums);
	/* 213.打家劫舍 II */ ==> 198 + rob the first or not
	int robII(vector<int>& nums);

IV.子数组问题
1.子数组内部运算问题
    /* 53.最大子数组和 */
    int maxSubArray(vector<int>& nums);
	/* 152.乘积最大子数组 */
	int maxProduct(vector<int>& nums);

2.交互问题
    /* 718.最长重复子数组 */	
    int findLength(vector<int>& nums1, vector<int>& nums2);
```



#### 题型分类

| 类型       | 例题                                                         |
| ---------- | ------------------------------------------------------------ |
| 数列问题   | [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)<br>[118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)<br>[119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/) |
| 字符串     | [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)<br>[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)<br>[132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)<br>[44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)<br/>[10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)<br>[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)<br>[140. 单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)<br>[343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)<br />[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/) |
| 序列       | [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)<br/>[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)<br/>[334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence)<br>[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)<br>[446. 等差数列划分 II - 子序列](https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/)<br>[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)<br>[673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)<br>[674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)<br/>[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)<br/>[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)<br/>[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)<br/>[337. 打家劫舍 II>](https://leetcode-cn.com/problems/house-robber-iii/) |
| 数组       | [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)<br/>[152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)<br/>[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/) |
| 股票问题   | [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)<br>[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)<br>[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)<br>[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)<br>[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)<br>[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/) |
| 类路径问题 | [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)<br>[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)<br>[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)<br>[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)<br>[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)<br>[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)<br>[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)<br>[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)<br>[746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)<br>[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)<br>[174. 地下城游戏](https://leetcode-cn.com/problems/dungeon-game/) |
| 背包问题   | [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)<br>[1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)<br>[494. 目标和](https://leetcode-cn.com/problems/target-sum/)<br>[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)<br>[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)<br>[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)<br>[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)<br>[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/) |
|            | [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)<br>[87. 扰乱字符串](https://leetcode-cn.com/problems/scramble-string/)<br>[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)<br>[97. 交错字符串](https://leetcode-cn.com/problems/interleaving-string/) |



### 贪心算法体系

#### 题型总结



#### 题型分类

| 类型 | 例题                                                         |
| ---- | ------------------------------------------------------------ |
|      | [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)<br />[44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)<br />[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)<br />[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)<br />[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)<br />[134. 加油站](https://leetcode-cn.com/problems/gas-station/)<br />[135. 分发糖果](https://leetcode-cn.com/problems/candy/)<br />[179. 最大数](https://leetcode-cn.com/problems/largest-number/)<br />[316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)<br />[321. 拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)<br />[330. 按要求补齐数组](https://leetcode-cn.com/problems/patching-array/)<br />[334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)<br />[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)<br />[397. 整数替换](https://leetcode-cn.com/problems/integer-replacement/)<br />[402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)<br />[406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)<br />[409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)<br />[410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)<br />[420. 强密码检验器](https://leetcode-cn.com/problems/strong-password-checker/)<br />[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)<br />[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)<br />[455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/) |



### 滑动窗口体系

#### 题型总结

#### 题型分类

| 类型 | 例题                                                         |
| ---- | ------------------------------------------------------------ |
|      | [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)<br />[30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)<br />[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)<br />[187. 重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)<br />[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)<br />[219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)<br />[220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)<br />[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)<br />[395. 至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)<br />[424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)<br />[438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)<br />[480. 滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)<br /> |



| 窗口内操作 | 数据结构                          | 例题                                                         |
| ---------- | --------------------------------- | ------------------------------------------------------------ |
| 无重复     | set                               | 3.无重复最长字串<br>剑指 Offer 48. 最长不含重复字符的子字符串 |
| 覆盖/包含  | dict+cnt                          | 76_最小覆盖子串<br>面试题 17.18. 最短超串                    |
| 和         | 变量sum                           | 209_长度最小的子数组<br>剑指 Offer II 008. 和大于等于 target 的最小子数组 |
| 积         | 变量mul                           | 滑窗内相乘除要考虑左指针不大于右指针<br>剑指 Offer II 009. 乘积小于 K 的子数组 |
| 最大/小值  | 单调递减/增队列                   | 剑指 Offer 59 - I. 滑动窗口的最大值<br>239_滑动窗口的最大值  |
| 变位词包含 | 一固一滑长度相等的双字典          | 剑指 Offer II 014. 字符串中的变位词<br>438. 找到字符串中所有字母异位词 |
| 替换字母   | 26字母数组 or counter.most_common | 424. 替换后的最长重复字符                                    |
| 中位数     | 难！                              |                                                              |

| 滑窗类型     | 例题                                                         |
| ------------ | ------------------------------------------------------------ |
| 变长滑窗     | 3.无重复最长字串<br/>76. 最小覆盖子串<br/>209. 长度最小的子数组 |
| 固定滑窗     | 30. 串联所有单词的子串<br/>187. 重复的DNA序列<br/>           |
| 上限固定滑窗 | 219. 存在重复元素 II                                         |

```python
线索：
	1.子串/连续子数组/连续子序列
	
知识点：
	1.窗口长度变化的双指针窗口
	2.窗口长度固定的单指针窗口

套路：
- 窗口长度变化
右指先行 -- 符合条件控制左指循环更新窗口 -- 更新窗口过程中在恰当时机进行结果更新
- 窗口长度固定
按固定长度切割出所有的子窗口 -- 对子窗口进行分析
- 窗口类型
根据题意选择适当的数据结构，如集合，字典，单调递减队列，无等。
窗口内无重复 -- 集合。
窗口内取最大值 -- 单调递减队列
- trick

变长窗口模板
#step1 定义维护的变量
left = 0 	#左指针
res = 0 	#定义实时更新的结果变量
record = xx #定义record的数据结构
other = xx 	#辅助判断的一些维护变量
#备注 窗左和窗右的更新顺序可以替换，如3就是先左，76就是先右。其次结果的更新可以独立出来也可以在更窗中，但一定要放在最后，否则最后一个指针更新不到了。如果更新结果嵌入左窗更新中，则return的时候要注意用if else
#step2 右指针开始移动
for right in range(len(xx)):
    #step3 更新窗口左侧
    while(右指针停止的条件)：
    	update record by left #窗口移除式更新
    	left += 1	            #移动左指针
    #step4 更新窗口右侧
    update record by right         #窗口添加式更新
    #step5 更新结果
    update res					#更新结果变量，往往和right left 有关。

```

### 前缀和体系

#### 题型总结

- 什么是前缀和？

> 前缀和是一个数组的某项下标之前(包括此项元素)的所有[数组元素](https://so.csdn.net/so/search?q=数组元素&spm=1001.2101.3001.7020)的和。
>
> 一维前缀和的公式：`sum[i] = sum[i-1] + arr[i]` ;
>
> `[i, j]`的区间和公式：`interval [i, j] = sum[j] - sum[i - 1]`;
>
> 二维前缀和的公式：`sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + arr[i][j]`

- 什么时候使用前缀和？

> 前缀和是一种预处理，用于降低查询时的时间复杂度。通常和哈希表一起使用，可以进一步降低时间复杂度。
>
> 举个例子：给定 ![[公式]](https://www.zhihu.com/equation?tex=n) 个整数，然后进行 ![[公式]](https://www.zhihu.com/equation?tex=m) 次询问，每次询问求一个区间内值的和。
>
> 如果用暴力写法，那每次询问都需要从区间左端点循环到区间右端点求和，时间复杂度较大。
>
> 这种时候就可以预先求出该数组的一维前缀和。
>
> 则 ![[公式]](https://www.zhihu.com/equation?tex=ans%3Dy%5BR%5D-y%5BL-1%5D) ，其中 ![[公式]](https://www.zhihu.com/equation?tex=L) 和 ![[公式]](https://www.zhihu.com/equation?tex=R) 是给定的区间。每次询问可直接输出答案，这样时间复杂度就降到了 ![[公式]](https://www.zhihu.com/equation?tex=O%28N%2BM%29) 。

- 核心代码

```c++

```

#### 题型分类

| 类型 | 例题                                                         |
| ---- | ------------------------------------------------------------ |
|      | [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)<br />[238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)<br />[303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)<br />[304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)<br />[497. 非重叠矩形中的随机点](https://leetcode-cn.com/problems/random-point-in-non-overlapping-rectangles/)<br />[523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)<br />[525. 连续数组](https://leetcode-cn.com/problems/contiguous-array/)<br />[528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)<br />[560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)<br />[724. 寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/)<br />[798. 得分最高的最小轮调](https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/)<br />[862. 和至少为 K 的最短子数组](https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/)<br />[930. 和相同的二元子数组](https://leetcode-cn.com/problems/binary-subarrays-with-sum/)<br />[974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)<br />[995. K 连续位的最小翻转次数](https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/) |



### 字典树体系

#### 题型总结

- 什么是字典树？

> 字典树，是一种空间换时间的数据结构，又称Trie树、前缀树，是一种树形结构(字典树是一种数据结构)，典型用于统计、排序、和保存大量字符串。**字典树把字符串看成字符序列，根据字符串中字符序列的先后顺序构造从上到下的树结构，树结构中的每一条边都对应着一个字符。字典树上存储的字符串被视为从根节点到某个节点之间的一条路径，并在终点节点上做个标记"该节点对应词语的结尾"**

- 什么时候使用字典树?

> 字典树的优点是利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。经常被搜索引擎系统用于文本词频统计。

- 核心代码

```c++

```

#### 题型分类

| 类型 | 例题                                                         |
| ---- | ------------------------------------------------------------ |
|      | [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)<br />[140. 单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)<br />[208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)<br />[211. 添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)<br />[212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)<br />[336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/)<br />[386. 字典序排数](https://leetcode-cn.com/problems/lexicographical-numbers/)<br />[421. 数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)<br />[440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)<br />[472. 连接词](https://leetcode-cn.com/problems/concatenated-words/)<br />[648. 单词替换](https://leetcode-cn.com/problems/replace-words/)<br />[676. 实现一个魔法字典](https://leetcode-cn.com/problems/implement-magic-dictionary/)<br />[677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)<br />[692. 前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/)<br />[720. 词典中最长的单词](https://leetcode-cn.com/problems/longest-word-in-dictionary/)<br />[745. 前缀和后缀搜索](https://leetcode-cn.com/problems/prefix-and-suffix-search/)<br />[792. 匹配子序列的单词数](https://leetcode-cn.com/problems/number-of-matching-subsequences/)<br />[820. 单词的压缩编码](https://leetcode-cn.com/problems/short-encoding-of-words/) |



### 单调栈体系

#### 题型总结

- 什么是单调栈？

> 单调栈分为单调递增栈和单调递减栈，单调递增栈即栈内元素保持单调递增的栈，同理单调递减栈即栈内元素保持单调递减的栈，跟单调队列差不多，但是只用到它的一端。

- 什么时候需要使用单调栈？

> 单调栈可以以 O(1) 的时间复杂度得知某个位置左右两侧比他大（或小）的数的位置，当你需要高效率获取某个位置左右两侧比他大（或小）的数的位置的的时候就可以用到单调栈。
>
> 求解数组中元素右边第一个比它小的元素的下标，从前往后，构造单调递增栈；
> 求解数组中元素右边第一个比它大的元素的下标，从前往后，构造单调递减栈；
> 求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递减栈；
> 求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递增栈。

- 核心代码块

```c++

```

#### 题型分类

| 类型 | 例题                                                         |
| ---- | ------------------------------------------------------------ |
|      | [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)<br />[84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)<br />[85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)<br />[316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)<br />[321. 拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)<br />[402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)<br />[456. 132 模式](https://leetcode-cn.com/problems/132-pattern/)<br />[496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)<br />[503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)<br />[581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)<br />[654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)<br />[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)<br />[768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)<br />[769. 最多能完成排序的块](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/)<br />[853. 车队](https://leetcode-cn.com/problems/car-fleet/)<br />[901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)<br />[907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)<br />[962. 最大宽度坡](https://leetcode-cn.com/problems/maximum-width-ramp/)<br />[975. 奇偶跳](https://leetcode-cn.com/problems/odd-even-jump/) |



### 桶排序体系

#### 题型总结

#### 题型分类

| 类型 | 例题                                                         |
| ---- | ------------------------------------------------------------ |
|      | [164. 最大间距](https://leetcode-cn.com/problems/maximum-gap/)<br />[220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)<br />[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)<br />[451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)<br />[692. 前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/)<br />[912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/) |



## 数据结构体系

### 二叉树体系

```
一、遍历
I)144、94、145 ==》前中后序遍历有三种方法：递归法、迭代法、模板法 ==》前序是自顶向下遍历，其他反之。
  - 对于递归法，写法基本是一致的，缺点是需要多写一个函数。
  - 对于迭代法，写法不一致。
    - 前序用栈(stack)模拟递归，注意入栈顺序是先右后左。
    - 后序与前序相似，入栈顺序相反，最后多一步reverse的操作。
    - 中序用栈(stack)和指针(cur)模拟递归，指针一边左下行一边入栈 ==》指空时，出栈修改指针 ==》指针右下		 行
  - 对于模板法，写法一致。增加nullptr的标志将入栈操作和取值操作分离，语法采用if-else，条件为标志判断。注	 意：1.入栈顺序和遍历顺序相反；2.读到nullptr时，要pop两次。

II)102 ==》层序遍历仅有一种迭代法。
  - 采用数据结构双向队列deque<TreeNode*>
  - 注意每一层循环遍历时，要提前int n = q.size()，而不能直接用q.size()，因为q的size一直发生变化。	
  
III)103 ==》之字形遍历 ==》在层序遍历的基础上增加顺序leftOrder标志位，控制双向队列deque的取值方向。

IV)105、106、889 ==》根据三序遍历重构问题关键就是找到左右子树划分点，再进行递归。
  - 前+中：在中序中查找前序的第一个节点
  - 前+后：在后序中查找前序的第二个节点
  - 中+后：在中序中查找后序的最后一个节点
  
二、二叉搜索树
两大题型：中序遍历二叉搜索树 || 有序数据结构构造二叉搜索树 
I)98、99、173、230 ==》这两题解题关键就在于知道二叉搜索树的中序遍历是有序的！==》采用中序遍历迭代/递归遍历。
  - 98：可以中序遍历之后再判断，也可以一边遍历一边判断。
  - 99：与写法类似，只是目的变成了找不有序的两个点。
  - 173：将中序迭代遍历写在next()函数中
  - 230：中序遍历到第K个结束

II)96、95 ==》有序数组任取一个点，左右两侧的数据刚好可以递归构造出二叉搜索树的左右子树集合，在左右两子树集              合中任意取一个就可以组合成一个二叉搜索树了。

III)105、106 ==》类似95和96，只是这两题加了一个平衡的条件，因此不能任取一点，只能取重点。

三、 二叉树的特征&&交互
两大题型：自顶向下(先序) || 自底向上(后序)【主要用于深度问题】
I) 100、617 ==》都是两棵树进行交互的问题，先对两者的根节点进行业务操作，再对左右节点递归操作。

II)226、101 ==》都是验证自身树特性问题，先对根节点/根左右进行业务操作，再对根左右节点/外内节点递归操作。

III)104、111、110 ==》涉及到深度问题一般都是自底向上的方针。其他都是细节问题。
	-104：max(left,right) + 1
	-111：return (left && right) ? min(left,right) + 1 : 1 + left + right;
	-110：自底向上求高度，如果不平衡则返回-1.
	
IV)199、513、404 ==》遍历问题 ==》根据目的灵活选择遍历顺序.
	-199：求右视图，带深度的自顶向下，根右左。
	-513：求左下角，带深度的自顶向下，根左右。
	-404：求左叶子之和，普通先序即可。
V)222 ==》完全二叉树特性 + 递归思想

四、路径问题
I)112、113、437、124 ==》dfs(自顶向下) + 回溯问题
	-112：不保存路径，仅仅返回bool ==》先序 + 判断业务 + return bool回溯
	-113：保存路径并返回 ==》先序 + 判断添加 + pop回溯路径
	-437：不保存路径，仅仅返回次数 ==》先序 + 前缀和业务 + 字典回溯
	-124：不保存路径，仅仅返回和值 ==》先序 + 累加业务 + 无回溯
II)129 ==》非根节点路径 ==》自底向上

五、填充指针问题
I)116、117 ==》遍历问题
	-116：因为是完美二叉树，所以每个节点的操作可以一致，因此可以采用dfs先序。
	-117：因为是普通二叉树，所以每个节点操作无法一致，最佳就是采用改动的层序遍历 + 链表思想。

```

| 二叉树操作       | 例题（LeetCode500）                                          |
| ---------------- | ------------------------------------------------------------ |
| 遍历             | [*144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)<br>[*94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)<br>[*145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)<br>[*102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)<br>[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)<br>[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)<br>[*105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)<br>[*106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)<br>[*889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)<br>[297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)<br>[331. 验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)<br>[449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/) |
| 二叉搜索树       | [*98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)<br/>[99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)<br/>[173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)<br>[230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)<br/>[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)<br/>[95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)<br>[108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)<br>[109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)<br>[*剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)<br>[114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/) |
| 二叉树特征&&交互 | [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)<br/>[*617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)<br/>[*226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)<br/>[*101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)<br/>[*104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)<br>[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)<br/>[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)<br/>[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)<br>[513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)<br>[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)<br>[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/) |
| 路径             | [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)<br>[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)<br>[437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)<br>[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)<br>[129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/) |
| 填充指针         | [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)<br>[117. 填充每个节点的下一个右侧节点](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/) |
| 祖先             | [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)<br>[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) |



### 链表体系

```python
常用套路：
快慢指针、插头法、化数组/堆栈进行处理
1.设计操作
当做增加、删除列表节点操作时，其实最重要的就是找到对应位置的前一个节点。

2.删除操作
删除节点关键：找到节点前的点，然后cur.next = cur.next.next。
- 删除目标值：遍历cur.next + 删除节点
- 删除倒数节点：双指针找倒数节点 + 删除节点
- 删除无头节点：换值
- 删除中间节点：快慢指针找中点
  偶数链表时 
    while fast and fast.next找到是前面的；
    while fast.next and fast.next.next找到的是后面的；
- 删除重复元素：单指针去重，双指针删重
- 删合为0的子集：前缀和字典 核心思想：到两个结点的前缀和如果相等，则意味着两个结点之间的结点和为零。

3.反转操作
- 反转全部：双指针+python联立技巧
- 反转部分：三指针穿针引线(更新removed变量！！)或者三指针拼接。
  反转部分如果采用拼接法：
    I.找到反转部分的右端点，切断链表并记录下一个点：cur.next, curNext = None, cur.next
    II.记录旧头
    III.反转链表得到新头
    IV.根据新旧头进行链表连接
    V.更新pre,cur到旧头进行下一部分连接
- 复杂的部分反转：如果题目允许，可以将链表转化为列表进行操作。

注意python联立有个坑，右侧是一起评估的，但左侧是依次赋值的。
cur.next, pre, cur = pre, cur, cur.next
pre, cur, cur.next = cur, cur.next, pre
两者是不同的，第二个是错误的，因为cur被修改之后，cur.next可能不存在了。

4.多链表交互操作
同时遍历双链表技巧：while l1 and l2 或者 while l1 or l2
链表长度不同陷进：有一个链表可能提前遍历结束了，此时无法取值和.next
- 两链表顺序相加：进位考虑 + 链表长度不同陷阱 + 同时遍历双链表技巧 
- 两链表逆序相加：堆栈法 + 头插/反转构建链表 or 反转链表之后再相加再反转
- 两有序链表有序合并：链表长度不同陷阱 + 同时遍历双链表技巧
- K个有序链表有序合并：小顶堆heapq排序 + 链表构建
- 两链表相交判断：类似浪漫法，一直往前走，走不通就走对方的路。

5.花式重排链表
- 重排链表总技巧：画模拟图 -》确定基点 -》找到基点的Nxt点赋名 -》基点连接Nxt点 -》更新基点

- 旋转：计算链表长度 + 确定切断点 + 双指针法找到倒数的切断点 + 基本拼接
- 分隔：提取特定节点重构链表 + 基本拼接
- 穿插重排：找链表中点 + 反转链表 + 重排
- 奇偶重排：提取特定节点重排 + 基本拼接
- 交换相邻节点：模拟过程 + 重排
- 交换指定节点：交换值

6.找点/子集/和
均法链表：采用//求basic，采用%求+1组数。
切分成多段链表：用相邻双指针，慢指针用于切断尾部，快指针用于探索下一个点。
快慢双指针找中点：
        fast = slow = head
        while fast and fast.next: ---->其他未固定模板，此处可以控制偶数时中点的位置，此时为后一个。
        while fast.next and fast.next.next ---->此时为前一个
            fast = fast.next.next
            slow = slow.next
        return slow
link转list：当link处理比较复杂的问题时，还是转成list较为方便。
找极值点：遍历夹逼法
- 分隔链表：均分链表 + 切分成多端链表
- 链表组件：集合判断存在情况 + 组件统计
- 寻找中间节点：快慢双指针找中点
- 下一个更大节点：凡是找右侧下一个更xx的点都是用起单调栈。
- 找局部极值点：link转list + 找极值点 + 求距离
- 孪生和：链表中点 + 链表反转 + 双链表相加

7.复制操作
- 复制复杂链表：字典映射链表获取全局节点 + 复制原链表的链接方式

8.环形链表
快慢指针：快指针每次两步，慢指针每次一步。
环形浪漫法：有环形总会相遇
- 环形链表判断：快慢指针 + 环形浪漫法
- 寻找环形入口：环形链表判断 + 首尾指针相遇处即入口

9.排序
- 插入排序：一旦涉及到插入操作，那一定是要找到插入点的前后结点赋名，这样看起来清晰。插入排序注意是要有一个已经排序好的前缀，插入点则要从头开始遍历。
- 归并排序：链表查找中点切分 + 递归切分 + 有序合并
	陷阱：划分列表时，要使用while fast.next or fast.next.next 否则列表长度为2时会出现死循环。
```



| 链表操作                  | 例题                                                         | 方法 |
| ------------------------- | ------------------------------------------------------------ | ---- |
| 设计                      | [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)<br>[x355. 设计推特](https://leetcode-cn.com/problems/design-twitter)<br>[x622. 设计循环队列](https://leetcode-cn.com/problems/design-circular-queue)<br>[x641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque)<br>[x705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset)<br>[x706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap)<br>[x1206. 设计跳表](https://leetcode-cn.com/problems/design-skiplist)<br>[x1472. 设计浏览器历史记录](https://leetcode-cn.com/problems/design-browser-history)<br>[x1670. 设计前中后队列](https://leetcode-cn.com/problems/design-front-middle-back-queue) | #1   |
| 删除目标值/节点/重复/子集 | [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)<br>[19. *删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)<br>[237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)<br/>[2095. 删除链表的中间节点](https://leetcode-cn.com/problems/delete-the-middle-node-of-a-linked-list/)<br>[82. *删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)<br/>[83. *删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)<br>[1171. 从链表中删去总和值为零的连续节点](https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/) | #2   |
| 反转全部/部分             | [206. *反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)<br>[92. *反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)<br>[25. *K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)<br>[2074. 反转偶数长度组的节点](https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups/) | #3   |
| 多链表交互                | [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers)<br>[445. *两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)<br>[21. *合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)<br>[23. *合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists)<br>[1669. 合并两个链表](https://leetcode-cn.com/problems/merge-in-between-linked-lists/)<br>[160. *相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)<br> | #4   |
| 花式重排                  | [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)<br>[86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)<br>[143. *重排链表](https://leetcode-cn.com/problems/reorder-list/)<br>[328. *奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list)<br>[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)<br>[1721. 交换链表中的节点](https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list)<br> | #5   |
| 找点/子集/和              | [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts)<br>[817. 链表组件](https://leetcode-cn.com/problems/linked-list-components/)<br>[876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list)<br>[1019. 链表中的下一个更大节点](https://leetcode-cn.com/problems/next-greater-node-in-linked-list/)<br>[2058. 找出临界点之间的最小和最大距](https://leetcode-cn.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points)<br>[2130. 链表最大孪生和](https://leetcode-cn.com/problems/maximum-twin-sum-of-a-linked-list) | #6   |
| 复制                      | [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer) | #7   |
| 环形                      | [141. *环形链表](https://leetcode-cn.com/problems/linked-list-cycle)<br>[142. *环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii) | #8   |
| 排序                      | [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list)<br>[148. *排序链表](https://leetcode-cn.com/problems/sort-list) | #9   |
| 缓存                      | [x146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache)<br>[x460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache) | #10  |
| 二叉树                    | [x109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree)<br>[x114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list)<br>[x1367. 二叉树中的列表](https://leetcode-cn.com/problems/linked-list-in-binary-tree) |      |



### 字符串体系

- 增

  使用 ‘+’ 可进行字符串的添加拼接；

- 改：

  注意：Python中的字符串是无法进行原地修改的，有以下几个修改字符串的方案：

  list(str) + ''.join(list)：转换成列表修改完之后再转换为字符串。

  使用内置函数：str.replace(old,new)进行原地修改。

- 查：

  使用内置函数：str.find(str, beg=0, end=len(string))

  手写kmp

- 删

```python
1.找字串
主旨：滑窗 or 动态规划
- 无重复最长字串
I.滑动set去重

- 最长回文子串
I.动态规划法(dp[i][j]表示s[i:j+1]字串是否为回文) or 中心扩散法(奇偶串)

- 最小覆盖字串
I.滑动dict+count计数

- 重复的DNA序列
I.固定的滑动dict + 单指针

2.变换
主旨：代码模拟
- Z字形变换
I.模拟Z形变换过程 + 方向变量flag

- 整数反转/回文数
I.通过求余反向遍历整数，
II.注意C++：-9/7=-1 -9%7=-2 Python：-9//7 = -2 -9%7=5 9%-7=-5。

- 字符串转换整数
I.去前空格 + 在字符串中提取除数字

- 整数转罗马数字
I.贪心算法(每次找最大能除的值)

- 罗马数字转整数
I.字典记录 + 两位一组遍历
II.字典记录 + 一位一组遍历 + 熟悉罗马数字特性

3.多字符串交互
- 最长公共前缀
I.利用python的zip()可以轻松提取字母，利用set()函数可以轻松的去重。
II.纯粹的遍历模拟，考察对循环的构造。

- 串联所有单词的子串
I.固定滑窗 + 字典统计

- 字符串相加/二进制求和
I.模拟竖式相加的流程 + 对进位的把控

- 字符串相乘
I.模拟优化的竖式相乘流程(先考虑单乘，再考虑进位)
II.充分利用python的enumerate特性。

- 字母异位词分组
I.字典统计 + 排序消除异位
```



| 字符串操作         | 例题                                                         |      |
| ------------------ | ------------------------------------------------------------ | ---- |
| 找子串             | [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)<br>[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)<br>[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)<br>[187. 重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/) | #1   |
| 变换               | [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)<br>[7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)<br/>[9. 回文数](https://leetcode-cn.com/problems/palindrome-number)<br>[8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)<br>[12. 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)<br>[13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)<br> | #2   |
| 多字符串交互       | [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)<br>[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)<br>[30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)<br>[415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)<br>[43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)<br>[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)<br>[67. 二进制求和](https://leetcode-cn.com/problems/add-binary/) | #3   |
| 括号               | [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)<br>[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)<br>[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/) |      |
| 正则               | [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)<br>[44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/) |      |
| 反转/翻转/花式反转 | 344.反转字符串【**首尾双指针**】<br> 541. 反转字符串II<br>151.翻转字符串里的单词<br>剑指 Offer 58 - II. 左旋转字符串 |      |
| 替换特殊字符       | 剑指Offer 05.替换空格#3                                      |      |
| 重复构成           | 459. 重复的子字符串【**kmp算法**】                           |      |

### 数组体系

```python
常用算法: 1.双指针 2.动态规划 3.单调栈

I.数和题型
	数组内任意几个数的和 ———— 双指针 1 15 16 18
    连续子数组的和（包含所有滑窗长度） ———— 动态规划 53
    
II.统计图题型（数和题型的升级 经过一些复杂的过程之后再求和）
	总体步骤:顺应题目趋势找解算关键点，如11求水最多的容器，那么就去找让水增多的方向，方向可以用双指针表示。
    双指针，动态规划，单调栈。
    
III.原地删除体系
	都是双指针
    

```



| 操作     | 例题                                                         | AC   |
| -------- | ------------------------------------------------------------ | ---- |
| 数和     | [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)<br>[15. 三数之和](https://leetcode-cn.com/problems/3sum/)<br>[16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)<br>[18. 四数之和](https://leetcode-cn.com/problems/4sum/)<br>[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)<br>[66. 加一](https://leetcode-cn.com/problems/plus-one/) |      |
| 统计图   | [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)<br/>[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)<br/>[x-d84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) |      |
| 原地删除 | [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)<br>[27. 移除元素](https://leetcode-cn.com/problems/remove-element/)<br>[80. 删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/) |      |
| 重排     | [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)<br>[48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/) |      |
| 搜索     | [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)<br>[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)<br/>[34. 在排序数组中查找元素的第一个](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)<br>[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)<br>[81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)<br>[57. 插入区间](https://leetcode-cn.com/problems/insert-interval/) |      |
| 模拟     | [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)<br>[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/) |      |
| 路径     | [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)<br>[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) |      |
| 交互     | [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)<br/>[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/) |      |
|          |                                                              |      |
|          |                                                              |      |
| 其他     | [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)<br>[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)<br>[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)<br>[73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)<br>[74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)<br>[75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)<br>[85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)<br>[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)<br/> |      |

## 关键词体系

### 子序列

1. 动态规划 2. 贪心算法 3

| 题号                                                         | 题解                      |
| ------------------------------------------------------------ | ------------------------- |
| [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences) | 动态规划                  |
| [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence) | 动态规划                  |
| [334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence) | 动态规划                  |
| [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence) | 动态规划                  |
| [446. 等差数列划分 II - 子序列](https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence) | 动态规划[hash]            |
| [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences) | dfs                       |
| [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence) | 动态规划                  |
| [594. 最长和谐子序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence) | 贪心算法                  |
| [659. 分割数组为连续子序列](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences) | 贪心算法、哈希表 + 最小堆 |
| [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence) | 动态规划 + 记忆vector     |
| [674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence) | 动态规划、贪心算法        |
| [730. 统计不同回文子序列](https://leetcode-cn.com/problems/count-different-palindromic-subsequences) | 三维动态规划              |
| [792. 匹配子序列的单词数](https://leetcode-cn.com/problems/number-of-matching-subsequences) | 桶                        |
| [873. 最长的斐波那契子序列的长度](https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence) | 动态规划                  |
| [891. 子序列宽度之和](https://leetcode-cn.com/problems/sum-of-subsequence-widths) | 数学                      |
| [940. 不同的子序列 II](https://leetcode-cn.com/problems/distinct-subsequences-ii) | 动态规划                  |
| [1081. 不同字符的最小子序列](https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters) | 贪心算法 + 单调栈         |
| [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence) | 动态规划                  |

### 子数组

1. 滑动窗口 2. 动态规划 3. 其他

| 题号                                                         | 题解                               |
| ------------------------------------------------------------ | ---------------------------------- |
| [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray) | 动态规划、分治                     |
| [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray) | 动态规划                           |
| [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum) | 滑动窗口、前缀和 + 二分查找        |
| [523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum) | 前缀和 + 哈希表                    |
| [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/) | 前缀和 + 哈希表                    |
| [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray) | 双指针 + 排序                      |
| [643. 子数组最大平均数 I](https://leetcode-cn.com/problems/maximum-average-subarray-i) | 滑动窗口                           |
| [689. 三个无重叠子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/) | 滑动窗口、前缀和 + 序列 动态规划   |
| [713. 乘积小于 K 的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/) | 滑动窗口、二分查找                 |
| [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/) | 动态规划、滑动窗口                 |
| [795. 区间子数组个数](https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum) | 动态规划、双指针、滑动窗口、单调栈 |
| [862. 和至少为 K 的最短子数组](https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k) | 滑动窗口 、前缀和+单调栈           |
| [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums) | 滑动窗口、前缀和+单调对了          |
| [918. 环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray) | 动态规划、Kanade 算法              |
| [930. 和相同的二元子数组](https://leetcode-cn.com/problems/binary-subarrays-with-sum) | 滑动窗口、前缀和+哈希表            |
| [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k) | 前缀和+哈希表                      |
| [978. 最长湍流子数组](https://leetcode-cn.com/problems/longest-turbulent-subarray) | 滑动窗口、动态规划                 |
| [992. K 个不同整数的子数组](https://leetcode-cn.com/problems/subarrays-with-k-different-integers) | 滑动窗口                           |

### 子串

1. 滑动窗口 2. 动态规划 3. 其他

| 题号                                                         | 题解         |
| ------------------------------------------------------------ | ------------ |
| [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters) | 滑动窗口     |
| [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring) | 动态规划     |
| [30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words) | 滑动窗口     |
| [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/) | 动态规划、栈 |
| [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring) | 滑动窗口     |
| [395. 至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters) | 滑动窗口     |
| [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern) | kmp          |
| [467. 环绕字符串中唯一的子字符串](https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/) | 遍历         |
| [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/) | 动态规划     |
| [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings) | 遍历         |
| [828. 统计子串中的唯一字符](https://leetcode-cn.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/) | 找规律       |

