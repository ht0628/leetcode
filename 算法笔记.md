### 快速总结

**HJ1** **字符串最后一个单词的长度**

```
str.strip([chars]):
	用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。
	chars -- 移除字符串头尾指定的字符序列。
	return -- 移除字符串头尾指定的字符生成的新字符串。
	
str.split(str="", num=string.count(str)):
	通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串
    str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。
    num -- 分割次数。默认为 -1, 即分隔所有。
    return -- 分割后的字符串列表。
```

**HJ2** **计算某字符出现次数**

```
str.lower():
	转换字符串中所有大写字符为小写。
	return -- 将字符串中所有大写字符转换为小写后生成的字符串。
	
str.count(sub, start= 0,end=len(string)):
	用于统计字符串里某个字符或子字符串出现的次数。
    sub -- 搜索的子字符串
    start -- 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。
    end -- 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个
    return -- 子字符串在字符串中出现的次数。
```

**HJ3** **明明的随机数**：

```python
list.sort(cmp=None, key=None, reverse=False)
	对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。
    cmp -- 可选参数, 如果指定了该参数会使用该参数的方法进行排序。
	key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
	reverse -- 排序规则，reverse = True 降序， reverse = False 升序（默认）。
    return -- 无，操作原列表

sorted(iterable, cmp=None, key=None, reverse=False)
	对所有可迭代的对象进行排序操作。
    iterable -- 可迭代对象。
    cmp -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。
    key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
    reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。
	return -- 返回重新排序的列表。
```

**HJ4** **字符串分隔**

```
重复行为 递归思想
```

**HJ5** **进制转换**

```
int(xxxx,16):把后一个参数改为2，8，16可以分别把2，8，16进制的数字转化为10进制。
bin(int(‘ff’,16)):（先转成10进制，再转成2进制。）
oct(0xf):（任何进制可以直接转8进制）
hex(int(‘17’,8)):（先转成10进制，再转成16进制）
```

**HJ6** **质数因子**

```
一个数a若能表示成两个数相乘，那么其中一个数必定 ≤ sqrt(a)。因此质因数用sqrt(a)作为阈值。
```

**HJ7** **取近似值**

```python
print(round(float(input())+0.0000001))
python对于浮点数存储有点抽风（4.5会存储成4.4999999），所以要加上0.0000001。

round( x [, n])
	返回浮点数x的四舍五入值。
    x -- 数值表达式。
	n -- 数值表达式，表示从小数点位数。
	return -- 浮点数x的四舍五入值。
    
```

**HJ8** **合并表记录**

```
map(function, iterable, ...)
	根据提供的函数对指定序列做映射。
	function -- 函数
	iterable -- 一个或多个序列
	return -- Python 3.x 返回迭代器。
from collections import defaultdict
遍历字典：for k,v in d.items()

```

**HJ9** **提取不重复的整数**

```
list[::-1]: 利用切片逆序列表、字符串等

利用内置函数逆转列表: list.reverse()

list转换为str: str = ''.join(list)
```

**HJ10** **字符个数统计**

```
set(str): 字符串无序去除一步到位

ord(char): 将字符转为十进制的ASCII码

str.replace(old, new[, max]): 
    old -- 将被替换的子字符串。
    new -- 新字符串，用于替换old子字符串。
    max -- 可选字符串, 替换不超过 max 次
    返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串
```

**HJ15** **求int型正整数在内存中存储时1的个数**

```
bin(x)
	x -- int 或者 long int 数字
	return -- 字符串。
```

**HJ50** **四则运算**

```
eval():将字符串转化为表达式 主要要将[]{}换成(' ')'
```



 





### 算法笔记

#### 双指针

##### 快慢双指针

​		概述：起点相同，一个奋勇向前（保持遍历），另一个牵制敌军（符合条件才向前）。

  - 例题1--条件与快指针的值有关。

    细节：慢指针是为了修改数组内的值。

    ```
    27.移除元素
    给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并原地修改输入数组。
    
    示例: 
    给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。
    ```

- 例题2 - 滑动窗口

  细节:  慢指针的移动是为了从窗口吐出值，若吐出多个可以使用while循环移动慢指针。

  字眼：连续子数组、数组和
  
  ```
  209.长度最小的子数组
  给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
  
  示例：
  输入：s = 7, nums = [2,3,1,2,4,3] 
  输出：2 
  解释：子数组 [4,3] 是该条件下的长度最小的子数组。
  ```

##### 首尾指针

​		概述：起点不同，一个从首出发，一个从尾部出发。

​		字眼：有序

- 例题1

  ```
  977.有序数组的平方
  给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
  
  示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]
  
  示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]
  ```

#### 

#### 螺旋矩阵

​		概述：考察对流程的模拟和边界的控制

​		字眼：螺旋

- 例题1 - 生成矩阵

  ```
  59、正方形螺旋矩阵
  给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
  
  示例:
  输入：n = 3
  输出：[[1,2,3],[8,9,4],[7,6,5]]
  ```

- 例题2 - 分解矩阵

  ```
  54. 螺旋矩阵
  给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
  
  示例:
  输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
  输出：[1,2,3,6,9,8,7,4,5]#### 
  ```


#### 二叉树的遍历

##### 递归遍历

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        def dfs(root):
            if not root: return
            ##业务逻辑
            root.left, root.right = root.right, root.left
			##
            dfs(root.left)
            dfs(root.right)
        
        dfs(root)
        return root
```

##### 迭代模板遍历

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root: return root

        stack = [root]
        while stack:
            node = stack.pop()
            if node != None:
                if node.right: stack.append(node.right)
                if node.left: stack.append(node.left)
                stack.append(node)
                stack.append(None)
            else:
                node = stack.pop()
                ##业务逻辑
                node.left,node.right = node.right,node.left
                ##
        return root
```

##### 层序模板遍历

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root: return root

        layer = [root]
        while layer:
            tmp = []
            for node in layer:
                ##业务逻辑
                node.left, node.right = node.right, node.left
                ##
                if node.left: tmp.append(node.left)
                if node.right: tmp.append(node.right)
            layer = tmp
        return root
    
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root: return root

        layer = [root]
        while layer:
            for _ in range(len(layer)):
                node = layer.pop(0)
                ##业务逻辑
                node.left, node.right = node.right, node.left
                ##
                if node.left: layer.append(node.left)
                if node.right: layer.append(node.right)
        return root
```

#### 二叉树题型

```
对于二叉树的题目：
1. dfs的有迭代法(stack,dequeue), 递归法。
2. bfs的有(dequeue)。
```



##### 对称二叉树--------双参递归迭代

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        ##递归法(1->确定函数的传参和返回值, 2->(函数中)确定终止条件, 3->(函数中)确定单层递归逻辑)
        # def dfs(left, right):
        #     if not left and not right: return True  
        #     if not left or not right: return False
        #     if left.val != right.val: return False

        #     return dfs(left.left, right.right) and dfs(left.right, right.left)
        
        # return dfs(root.left, root.right)

        #迭代法(1->确定数据结构 堆栈or双向队列 2->弹出数据进入业务逻辑 3->载入数据)
        from collections import deque
        #1
        q = deque([root.left,root.right])       
        while q:
            #2
            l = q.popleft()                     
            r = q.popleft()
            if not l and not r: continue    #都是空节点，那么是无法添加子结点的, 故直接continue。
            if not l or not r: return False #一空一有，必定不对称了。
            if l.val != r.val: return False #都有但值不相等，必定不对称了。
            #3
            q.append(l.left)
            q.append(r.right)
            q.append(l.right)
            q.append(r.left)

        return True
```

